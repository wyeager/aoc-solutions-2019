(ns aoc-solutions-2019.core
    (:require
     [reagent.core :as r]
     [clojure.string]
     [cljs.reader]))

;; Project generated by following instructions here: https://github.com/reagent-project/reagent
;; then by running:
;; lein new reagent-frontend myproject

;; this syntax for writing HTML is called Hiccup: http://reagent-project.github.io/docs/master/UsingHiccupToDescribeHTML.html

;; Solutions code
(def solutions `({:name "Problem 1 (part 1)"
                  :code "
(defn get-numbers [lines]
  (let [str-numbers (clojure.string/split lines #\"\\s+\")
        numbers (map js/parseInt str-numbers)]
    numbers))

(defn find-fuel-req
  \"To find the fuel required for a module, take its mass, 
   divide by three, round down, and subtract 2.
   Currently not accounting for inputs which would result 
   in 0 or negative amounts of fuel.\"
  [mass]
  (- (js/Math.floor (/ mass 3)) 2))

(defn problem-1-part-1
  \"Solves part 1 of problem 1: 
   https://adventofcode.com/2019/day/1#part1. Expects a string 
   of white space separated numbers.\"
  [module-masses-input]
  (let [masses (get-numbers module-masses-input)]
    (reduce + (map find-fuel-req masses))))"}
                 {:name "Problem 1 (part 2)"
                  :code "
(defn find-fuel-part-2 [mass-input]
  (loop [mass mass-input
         total 0]
    (if (<= mass 8)
      total
      (let [fuel (find-fuel-req mass)]
        (recur fuel (+ fuel total))))))

(defn problem-1-part-2
  \"Solves part 1 of problem 2: 
   https://adventofcode.com/2019/day/1#part2. Expects a string
   of white space separated numbers.\"
  [module-masses-input]
  (let [masses (get-numbers module-masses-input)]
    (reduce + (map find-fuel-part-2 masses))))
"}
                 {:name "Problem 2 (part 1)"
                  :code "
(defn get-numbers [lines regex]
  (let [str-numbers (clojure.string/split lines regex)
        numbers (map js/parseInt str-numbers)]
    numbers))

(defn process-op-codes
  \"Expects a vector of 4 numbers\"
  [op-codes program]
  (let [op (op-codes 0)
        ;; get value at index of program given by element of subvector
        first-operand (program (op-codes 1))
        second-operand (program (op-codes 2))
        ops {1 + 2 *}]
    ((ops op) first-operand second-operand)))

(defn process-program
  \"Expects a vector of numbers. Assumes all programs are terminated by a 99 operation\"
  [program]
  (loop [modified-program program
         start-index 0]
    (let [end-index (+ start-index 4)
          sub-vector (subvec modified-program start-index end-index)]
      (if (= 99 (first sub-vector))
        ;; base case: return first element of modified program
        (first modified-program)
        ;; otherwise calculate value based on sub vector and replace element of program with specified index
        (let [res (process-op-codes sub-vector modified-program)
              replacement-index (sub-vector 3)]
          (recur (assoc modified-program replacement-index res) end-index))))))

(defn problem-2-part-1 [program-str]
  (let [program-arr (vec (get-numbers program-str #\",\"))
        program-replace-digits (assoc program-arr 1 12 2 2)]
    (process-program program-replace-digits)))
"}
                 {:name "Problem 2 (part 2)"
                  :code "
(defn problem-2-part-1 [program-str noun verb]
  (let [program-arr (vec (get-numbers program-str #\",\"))
        program-replace-digits (assoc program-arr 1 noun 2 verb)]
    (process-program program-replace-digits)))

;; warning: really ugly clojure incoming, nesting loops is something I'm struggling to do recursively
;; I'd like to return to this to tidy it up
(defn problem-2-part-2 [program-str]
  (loop [x 0]
    (loop [y 0]
      (if (= (problem-2-part-1 program-str x y) 19690720)
        (println (str \"Solution: \" x \" \" y \" then multiply x by 100 and add y: \" (+ y (* 100 x))))
        nil)
      (if (> y 99)
        nil
        (recur (inc y))))
    (if (> x 99)
      nil
      (recur (inc x)))))
"}))

;; -------------------------
;; Views

(defn solution [name code]
  [:div
   [:h3 name]
   [:pre {:style {:background-color "rgb(248, 248, 248)"
                  :overflow-x "scroll"}}
    [:code code]]])

(defn main-description []
  [:p "In an effort to learn Clojurescript and Reagent I am going to try to solve each of the "
   [:a {:href "https://adventofcode.com/"} "Advent of Code"]
   " challenges (in Clojure) and post my solutions here. Along with posting the solutions I'd also like to "
   "flush out the website as I go, perhaps by adding features like the ability to search for solutions or "
   "experimenting with different CSS frameworks."])

(defn home-page []
  [:div 
   [:h2 "Advent of Code Solutions 2019"]
   [main-description]
   [:div (map (fn [sol] 
               [:div [solution (sol :name) (sol :code)]])
             solutions)]])

;; -------------------------
;; Initialize app

(defn mount-root []
  (r/render [home-page] (.getElementById js/document "app")))

(defn init! []
  (mount-root))

;; Utils

(defn get-numbers [lines regex]
  (let [str-numbers (clojure.string/split lines regex)
        numbers (map js/parseInt str-numbers)]
    numbers))

;; Solutions

;; Problem 1 Part 1

(defn find-fuel-req
  "To find the fuel required for a module, take its mass, divide by three, round down, and subtract 2.
   Currently not accounting for inputs which would result in 0 or negative amounts of fuel."
  [mass]
  (- (js/Math.floor (/ mass 3)) 2)
  )

(defn find-fuel-part-2 [mass-input]
  (loop [mass mass-input
         total 0]
    (if (<= mass 8)
      total
      (let [fuel (find-fuel-req mass)]
        (recur fuel (+ fuel total))))))

(defn problem-1-part-1 
  "Solves part 1 of problem 1: https://adventofcode.com/2019/day/1#part1. Expects a string of white space separated numbers."
  [module-masses-input]
  (let [masses (get-numbers module-masses-input #"\s+")]
    (reduce + (map find-fuel-req masses))))

;; Problem 1 Part 2

(defn problem-1-part-2
  "Solves part 1 of problem 2: https://adventofcode.com/2019/day/1#part2. Expects a string of white space separated numbers."
  [module-masses-input]
  (let [masses (get-numbers module-masses-input #"\s+")]
    (reduce + (map find-fuel-part-2 masses))))

(defn get-program-arr [program-str]
  (clojure.string/split program-str #",")
  )

(defn process-op-codes 
  "Expects a vector of 4 numbers"
  [op-codes program]
  (let [op (op-codes 0)
        ;; get value at index of program given by element of subvector
        first-operand (program (op-codes 1))
        second-operand (program (op-codes 2))
        ops {1 + 2 *}]
    ((ops op) first-operand second-operand)
    )
  )

(defn process-program 
  "Expects a vector of numbers. Assumes all programs are terminated by a 99 operation"
  [program]
  (loop [modified-program program
         start-index 0]
    (let [end-index (+ start-index 4)
          sub-vector (subvec modified-program start-index end-index)]
      (if (= 99 (first sub-vector))
        ;; base case: return first element of modified program
        (first modified-program)
        ;; otherwise calculate value based on sub vector and replace element of program with specified index
        (let [res (process-op-codes sub-vector modified-program)
              replacement-index (sub-vector 3)]
          (recur (assoc modified-program replacement-index res) end-index)))))
  )

(defn problem-2-part-1 [program-str noun verb]
  (let [program-arr (vec (get-numbers program-str #","))
        program-replace-digits (assoc program-arr 1 noun 2 verb)]
    (process-program program-replace-digits)
    )
  )

;; warning: really ugly clojure incoming, nesting loops is something I'm struggling to do recursively
(defn problem-2-part-2 [program-str]
  (loop [x 0]
    (loop [y 0]
      (if (= (problem-2-part-1 program-str x y) 19690720)
        (println (str "Solution: " x " " y " then multiply x by 100 and add y: " (+ y (* 100 x))))
        nil
        )
      (if (> y 99)
        nil
        (recur (inc y))))
    (if (> x 99)
      nil
      (recur (inc x))))
  )